#!/usr/bin/env node
/**
 * Research Ledger Report Generator
 * Generates MASTER-INDEX.md from research.db views
 * Part of ADR-038 Research Ledger System
 */

const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');

const DB_PATH = path.join(__dirname, '../db/research.db');
const OUTPUT_PATH = path.join(__dirname, '../MASTER-INDEX.md');

/**
 * Format number with thousands separator
 */
function formatNumber(n) {
  if (n == null) return '0';
  return n.toLocaleString('en-US');
}

/**
 * Format percentage with 1 decimal place
 */
function formatPercent(n) {
  if (n == null) return '0.0%';
  return `${Number(n).toFixed(1)}%`;
}

/**
 * Align markdown table columns with pipes
 */
function alignTable(rows) {
  if (rows.length === 0) return '';

  const widths = [];
  rows.forEach(row => {
    const cells = row.split('|').map(c => c.trim()).filter(c => c);
    cells.forEach((cell, i) => {
      widths[i] = Math.max(widths[i] || 0, cell.length);
    });
  });

  return rows.map((row, idx) => {
    const cells = row.split('|').map(c => c.trim()).filter(c => c);
    const aligned = cells.map((cell, i) => {
      if (idx === 1 && cell.startsWith('-')) {
        return '-'.repeat(widths[i]);
      }
      return cell.padEnd(widths[i]);
    });
    return '| ' + aligned.join(' | ') + ' |';
  }).join('\n');
}

/**
 * Generate the master index report
 */
function generateReport() {
  const db = new Database(DB_PATH, { readonly: true });
  db.pragma('foreign_keys = ON');

  const sections = [];

  // 1. Header
  sections.push(`# Research Ledger — ruvnet Multi-Repo Universe`);
  sections.push(`> Auto-generated by \`scripts/report.js\` — do not edit manually`);
  sections.push(`> Last updated: ${new Date().toISOString()}`);
  sections.push('');

  // 2. Overall Stats
  sections.push(`## Overall Statistics\n`);

  const stats = db.prepare(`
    SELECT
      COUNT(DISTINCT package_id) as total_packages,
      COUNT(*) as total_files,
      COALESCE(SUM(loc), 0) as total_loc,
      SUM(CASE WHEN depth = 'DEEP' THEN 1 ELSE 0 END) as deep_count,
      SUM(CASE WHEN depth = 'MEDIUM' THEN 1 ELSE 0 END) as medium_count,
      SUM(CASE WHEN depth = 'SURFACE' THEN 1 ELSE 0 END) as surface_count,
      SUM(CASE WHEN depth = 'MENTIONED' THEN 1 ELSE 0 END) as mentioned_count,
      SUM(CASE WHEN depth = 'NOT_TOUCHED' THEN 1 ELSE 0 END) as untouched_count,
      SUM(CASE WHEN depth = 'EXCLUDED' THEN 1 ELSE 0 END) as excluded_count
    FROM files
    WHERE depth != 'EXCLUDED'
  `).get();

  const totalFiles = stats.total_files || 0;
  const deepPct = totalFiles > 0 ? (stats.deep_count / totalFiles * 100) : 0;
  const mediumPct = totalFiles > 0 ? (stats.medium_count / totalFiles * 100) : 0;
  const surfacePct = totalFiles > 0 ? (stats.surface_count / totalFiles * 100) : 0;
  const mentionedPct = totalFiles > 0 ? (stats.mentioned_count / totalFiles * 100) : 0;
  const untouchedPct = totalFiles > 0 ? (stats.untouched_count / totalFiles * 100) : 0;

  sections.push(`- **Total packages:** ${formatNumber(stats.total_packages)}`);
  sections.push(`- **Total files inventoried:** ${formatNumber(stats.total_files)}`);
  sections.push(`- **Total LOC:** ${formatNumber(stats.total_loc)}`);
  sections.push(`\n**Coverage Breakdown:**\n`);
  sections.push(`- DEEP: ${formatNumber(stats.deep_count)} (${formatPercent(deepPct)})`);
  sections.push(`- MEDIUM: ${formatNumber(stats.medium_count)} (${formatPercent(mediumPct)})`);
  sections.push(`- SURFACE: ${formatNumber(stats.surface_count)} (${formatPercent(surfacePct)})`);
  sections.push(`- MENTIONED: ${formatNumber(stats.mentioned_count)} (${formatPercent(mentionedPct)})`);
  sections.push(`- NOT_TOUCHED: ${formatNumber(stats.untouched_count)} (${formatPercent(untouchedPct)})`);
  sections.push('');

  // 3. Coverage by Domain
  sections.push(`## Coverage by Domain\n`);

  const domains = db.prepare(`
    SELECT
      name,
      priority,
      total_files,
      total_loc,
      deep_files,
      medium_files,
      surface_files,
      not_touched_files,
      pct_loc_covered
    FROM domain_coverage
    ORDER BY
      CASE priority
        WHEN 'HIGH' THEN 1
        WHEN 'MEDIUM' THEN 2
        WHEN 'LOW' THEN 3
        ELSE 4
      END,
      name
  `).all();

  if (domains.length > 0) {
    const rows = [
      '| Domain | Priority | Files | LOC | Deep | Med | Surface | Untouched | % Covered |',
      '|--------|----------|-------|-----|------|-----|---------|-----------|-----------|'
    ];

    domains.forEach(d => {
      rows.push(
        `| ${d.name} | ${d.priority} | ${formatNumber(d.total_files)} | ${formatNumber(d.total_loc)} | ` +
        `${formatNumber(d.deep_files)} | ${formatNumber(d.medium_files)} | ${formatNumber(d.surface_files)} | ` +
        `${formatNumber(d.not_touched_files)} | ${formatPercent(d.pct_loc_covered)} |`
      );
    });

    sections.push(alignTable(rows));
  } else {
    sections.push('*No domain coverage data yet — tag files with domains to see coverage.*');
  }
  sections.push('');

  // 4. Coverage by Package
  sections.push(`## Coverage by Package\n`);

  const packages = db.prepare(`
    SELECT
      name,
      total_files,
      total_loc,
      deep_files,
      medium_files,
      surface_files,
      not_touched_files,
      pct_loc_covered
    FROM package_coverage
    ORDER BY name
  `).all();

  if (packages.length > 0) {
    const rows = [
      '| Package | Files | LOC | Deep | Med | Surface | Untouched | % Covered |',
      '|---------|-------|-----|------|-----|---------|-----------|-----------|'
    ];

    packages.forEach(p => {
      rows.push(
        `| ${p.name} | ${formatNumber(p.total_files)} | ${formatNumber(p.total_loc)} | ` +
        `${formatNumber(p.deep_files)} | ${formatNumber(p.medium_files)} | ${formatNumber(p.surface_files)} | ` +
        `${formatNumber(p.not_touched_files)} | ${formatPercent(p.pct_loc_covered)} |`
      );
    });

    sections.push(alignTable(rows));
  } else {
    sections.push('*No packages inventoried yet.*');
  }
  sections.push('');

  // 5. Integration Hotspots
  sections.push(`## Integration Hotspots\n`);
  sections.push('*Files appearing in 3+ domains (cross-cutting concerns)*\n');

  const hotspots = db.prepare(`
    SELECT
      relative_path,
      package_name,
      loc,
      depth,
      domains,
      domain_count
    FROM integration_hotspots
    ORDER BY domain_count DESC, loc DESC
  `).all();

  if (hotspots.length > 0) {
    const rows = [
      '| File | Package | LOC | Depth | Domains | Count |',
      '|------|---------|-----|-------|---------|-------|'
    ];

    hotspots.forEach(h => {
      rows.push(
        `| ${h.relative_path} | ${h.package_name} | ${formatNumber(h.loc)} | ${h.depth} | ` +
        `${h.domains} | ${h.domain_count} |`
      );
    });

    sections.push(alignTable(rows));
  } else {
    sections.push('*No integration hotspots found yet — tag files with domains to discover them.*');
  }
  sections.push('');

  // 6. Priority Gaps (smart, relevance-tiered)
  sections.push(`## Priority Gaps (Top 20)\n`);
  sections.push('*Relevance-tiered: CONNECTED/OWN_CODE (rank 1) → PROXIMATE (2) → NEARBY (3) → DOMAIN_ONLY (4)*\n');

  const gaps = db.prepare(`
    SELECT
      domain_name,
      package_name,
      relative_path,
      loc,
      relevance_tier,
      tier_rank
    FROM smart_priority_gaps
    ORDER BY tier_rank ASC, loc DESC
    LIMIT 20
  `).all();

  if (gaps.length > 0) {
    const rows = [
      '| Tier | Domain | Package | File | LOC |',
      '|------|--------|---------|------|-----|'
    ];

    gaps.forEach(g => {
      rows.push(
        `| ${g.relevance_tier} | ${g.domain_name} | ${g.package_name} | ${g.relative_path} | ${formatNumber(g.loc)} |`
      );
    });

    sections.push(alignTable(rows));
  } else {
    sections.push('*No priority gaps — all HIGH priority files are covered!*');
  }
  sections.push('');

  // 7. Open Findings
  sections.push(`## Open Findings\n`);

  const findings = db.prepare(`
    SELECT
      severity,
      category,
      file_path,
      package_name,
      line_start,
      line_end,
      description
    FROM open_findings
  `).all();

  if (findings.length > 0) {
    const rows = [
      '| Severity | Category | File | Package | Lines | Description |',
      '|----------|----------|------|---------|-------|-------------|'
    ];

    findings.forEach(f => {
      const lines = f.line_start
        ? (f.line_end ? `${f.line_start}-${f.line_end}` : `${f.line_start}`)
        : '-';
      const desc = f.description && f.description.length > 80
        ? f.description.substring(0, 77) + '...'
        : (f.description || '');
      rows.push(
        `| ${f.severity} | ${f.category || '-'} | ${f.file_path} | ${f.package_name} | ${lines} | ${desc} |`
      );
    });

    sections.push(alignTable(rows));
  } else {
    sections.push('*No open findings.*');
  }
  sections.push('');

  // 8. Package Dependency Map
  sections.push(`## Package Dependency Map\n`);

  const deps = db.prepare(`
    SELECT
      p1.name as source,
      p2.name as target,
      pd.relationship,
      pd.notes
    FROM package_dependencies pd
    JOIN packages p1 ON pd.source_package_id = p1.id
    JOIN packages p2 ON pd.target_package_id = p2.id
    ORDER BY p1.name, p2.name
  `).all();

  if (deps.length > 0) {
    deps.forEach(d => {
      const note = d.notes ? ` — ${d.notes}` : '';
      sections.push(`- **${d.source}** → ${d.target} *(${d.relationship})*${note}`);
    });
  } else {
    sections.push('*No package dependencies recorded yet.*');
  }
  sections.push('');

  // 9. Domain Index
  sections.push(`## Domain Index\n`);

  const domainList = db.prepare(`
    SELECT name, priority, synthesis_path
    FROM domains
    ORDER BY
      CASE priority
        WHEN 'HIGH' THEN 1
        WHEN 'MEDIUM' THEN 2
        WHEN 'LOW' THEN 3
        ELSE 4
      END,
      name
  `).all();

  if (domainList.length > 0) {
    domainList.forEach(d => {
      const link = d.synthesis_path || `domains/${d.name}/analysis.md`;
      sections.push(`- [${d.name}](${link}) — **${d.priority}**`);
    });
  } else {
    sections.push('*No domains defined yet.*');
  }
  sections.push('');

  // Footer
  sections.push('---');
  sections.push('*Generated by research ledger system (ADR-038)*');
  sections.push('');

  db.close();

  return sections.join('\n');
}

// Main execution
try {
  console.log('Generating MASTER-INDEX.md from research.db...');

  if (!fs.existsSync(DB_PATH)) {
    console.error(`ERROR: Database not found at ${DB_PATH}`);
    console.error('Run: node scripts/init-db.js');
    process.exit(1);
  }

  const report = generateReport();
  fs.writeFileSync(OUTPUT_PATH, report, 'utf8');

  console.log(`Generated ${OUTPUT_PATH}`);
  console.log(`  ${report.split('\n').length} lines`);
  console.log(`  ${report.length.toLocaleString()} bytes`);

} catch (error) {
  console.error('ERROR generating report:', error.message);
  console.error(error.stack);
  process.exit(1);
}
